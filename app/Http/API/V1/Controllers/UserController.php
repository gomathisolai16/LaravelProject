<?php

namespace App\Http\API\V1\Controllers;

use App\Models\EmailAlerts;
use App\Services\EmailAlertService;
use Illuminate\Support\Facades\DB;
use App\Additional\Controllers\UserAdditional;
use App\Events\UserCreatedEvent;
use App\Http\Controllers\ApiController;
use App\Http\API\V1\Requests\UserRequest;
use App\Models\Setting;
use App\Models\User;
use App\Models\UserWatchList;
use App\Models\UserTicker;
use App\Services\ModelService;
use App\Services\ResponseService;
use App\Services\RoleService;
use App\Services\UserService;
use App\Services\WatchListService;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Schema;
use Illuminate\Validation\UnauthorizedException;

/**
 * Class UserController
 * @package App\Http\API\V1\Controllers
 */
class UserController extends ApiController
{
    use UserAdditional;

    /**
     * @var string $_for
     */
    protected $_for = "users";

    /**
     * @var string $_modelClass
     */
    protected $_modelClass = User::class;

    /**
     * @var string $_requestClass
     */
    protected $_requestClass = UserRequest::class;


    /**
     * @return \Illuminate\Http\JsonResponse
     * @throws \Exception
     */
    public function index()
    {
        RoleService::checkPermissions('read-users');
        return parent::index(); // TODO: Change the autogenerated stub
    }

    /**
     * @return \Illuminate\Http\JsonResponse
     * @throws \Exception
     */
    public function store()
    {
        RoleService::checkPermissions('create-user');
        $multiple = request()->filled('users');
        $itemName = $this->_getSingleItemKey();

        if ($multiple) {
            $this->__getData();
        } else {
            $this->_checkRequest();
            $this->_data = UserService::resolveData(request()->all());
        }

        $inserted = User::insert($this->_data);

        if (!$inserted) {
            throw new \Exception(trans('exception.canNotSave', ['item' => ucfirst($itemName)]));
        }

        if ($multiple) {
            $data = $this->_model->lastInserted(count($this->_data))->get();
            foreach ($data as $user) {
                event(new UserCreatedEvent($user));
            }
        } else {
            $data = $this->_data;
            event(new UserCreatedEvent($this->_model->lastInserted(1)->first()));
            unset($data['password']);
        }

        $this->_message = trans('message.saved', ['item' => ucfirst($itemName)]);

        return $this->_responseService
            ->format($this->_format)
            ->withStatus($this->_status)
            ->single($data, $itemName, $this->_message);
    }

    /**
     * @param int $id
     * @return \Illuminate\Http\JsonResponse
     * @throws \Exception
     */
    public function destroy($id)
    {
        RoleService::checkPermissions('delete-user');
        if (!Auth::user()->hasRole('admin')) {
            throw new UnauthorizedException('Authenticated user is not an admin.');
        }
        if (Auth::user()->id == $id) {
            throw new UnauthorizedException('You cannot delete your own account');
        }
        return parent::destroy($id);
    }

    /**
     * @return \Illuminate\Http\JsonResponse
     * @throws \Exception
     */
    public function delete()
    {
        RoleService::checkPermissions('delete-user');
        if (!Auth::user()->hasRole('admin')) {
            throw new UnauthorizedException('Authenticated user is not an admin.');
        }
        $request = request()->all(['username']);
        if (empty($request['username'])) {
            throw new \InvalidArgumentException('You must send username.');
        }

        $user = User::where('username', '=', $request['username'])->first();
        if (!$user) {
            throw new UnauthorizedException(trans('auth.user-not-existent-error'));
        }
        if (Auth::user()->id === $user->id) {
            throw new UnauthorizedException("You can't delete your own account.");
        }

        $this->_message = ucfirst($user->username) . " has been deleted";
        $deletedItem = $user->delete();

        if (!$deletedItem) {
            throw new \Exception(trans('exception.canNotDelete', ['item' => ucfirst($user)]));
        }

        // remove cache if model is instanceof ICachable interface
        ModelService::removeCacheIfExists();

        return $this->_responseService
            ->format($this->_format)
            ->withStatus($this->_status)
            ->single($user->toArray(), "User", $this->_message);
    }

    /**
     * @param int $id
     * @return \Illuminate\Http\JsonResponse
     * @throws \Exception
     */
    public function update($id)
    {
        RoleService::checkPermissions('edit-user');

        $item = $this->_model->find($id);
        if (!$item) {
            throw new \Exception(trans('exception.recordNotFound', ['item' => 'User', 'id' => $id]));
        }
        // Data provided to update current fields
        $providedData = request()->all();
        if (empty($providedData)) {
            throw new \InvalidArgumentException('There are no new data provided to update user record');
        }
        if (isset($providedData['password'])) {
            $providedData['password'] = bcrypt($providedData['password']);
        }
        $updated = $item->update($providedData);
        if (!$updated) {
            throw new \Exception(trans('exception.canNotUpdate', ['item' => $item, 'id' => $id]));
        }
        
        return $this->_responseService
            ->format($this->_format)
            ->withStatus($this->_status)
            ->single($item->toArray(), 'user', 'User updated successfully');
    }

    /**
     * Will return authenticated user with roles and permissions as response
     *
     * @param User $userM
     * @param ResponseService $responseService
     * @return \Illuminate\Http\JsonResponse
     * @throws \Exception
     */
    public function authUser(User $userM, ResponseService $responseService)
    {
        $user = ModelService::applyRelations($userM);
        $id = Auth::id();

        $user = Cache::remember('auth_user_' . $id, config('cache.time'), function () use ($id, $user) {
            return $user->where('id', $id)->with([
                'roles' => function ($roles) {
                    $roles->with('permissions');
                }
            ])->first();
        });

        return $responseService->single($user, 'user');
    }

    /**
     * @param $id
     * @return \Illuminate\Http\JsonResponse
     * @throws \Exception
     */
    public function deleteWatchList($id)
    {
        if (!Schema::hasTable("user_ticker")) {
            throw new \Exception(trans('exception.table', ['table' => 'ticker']));
        }
        $user = Auth::user();
        $watchListItem = UserWatchList::where(['user_id' => $user->id, 'id' => $id])->first();

        if (!$watchListItem) {
            throw new \Exception(trans('exception.recordNotFound', ['item' => ucfirst('watchlist'), 'id' => $id]));
        }

        $watchListItem->delete();
        return $this->_responseService
            ->format($this->_format)
            ->withStatus($this->_status)
            ->single($watchListItem, ucfirst('watchlist'), $watchListItem->id . " has been removed");
    }

    /**
     * @return \Illuminate\Http\JsonResponse
     */
    public function getWatchListItems()
    {
        $user = Auth::user();
        $res = app(UserWatchList::class)->userWatchListRecords($user->id, true);
        $size = sizeof($res);
        return $this->_responseService
            ->withStatus($this->_status)
            ->multiple($size, $size, $res);
    }

    /**
     * Change the status of an user.
     *
     * @return \Illuminate\Http\JsonResponse
     */
    public function changeUserStatus()
    {
        $authenticatedUser = Auth::user();
        if (!$authenticatedUser->hasRole('admin')) {
            throw new UnauthorizedException('Authenticated user is not an admin.');
        }

        $request = request()->all(['username', 'status']);
        if (empty($request['username'])) {
            throw new \InvalidArgumentException('You must send username and status.');
        }
        if (empty($request['status'])) {
            throw new \InvalidArgumentException('You must send the status in your request.');
        }
        if (!in_array($request['status'], User::$_userStatuses)) {
            throw new \InvalidArgumentException('You must send either trial|demo|regular|canceled|suspended|trial-incomplete as the status.');
        }

        $user = User::where('username', '=', $request['username'])->first();
        if ($user == null) {
            throw new UnauthorizedException(trans('auth.user-not-existent-error'));
        }
        if (Auth::user()->id == $user->id) {
            throw new UnauthorizedException("You can't change your own status.");
        }
        $user->status = $request['status'];
        $user->save();
        return $this->_responseService
            ->withStatus($this->_status)
            ->single($user->toArray());
    }

    /**
     * @return \Illuminate\Http\JsonResponse
     * @throws \InvalidArgumentException|\Exception
     */
    public function addWatchList()
    {
        $request = request()->all(['tickers']);

        if (is_null($request['tickers'])) {
            throw new \InvalidArgumentException('You must send at least one of the possible fields tickers');
        }

        if (empty($request['tickers'])) {
            throw new \InvalidArgumentException('Watchlist should have at least one ticker to be valid');
        }

        if (!request()->filled('name')) {
            throw new \InvalidArgumentException('Watchlist should have a valid name to be easily identified');
        }

        $user = Auth::user();
        $canAddNewWatchList = app(UserWatchList::class)->canUserAddWatchList($user->id);
        if (!$canAddNewWatchList) {
            throw new \InvalidArgumentException('You have already 3 Watch List records registered');
        }

        if (!empty($request['tickers'])) {
            $record = UserWatchList::create(['user_id' => $user->id, 'name' => request()->get('name')]);
            WatchListService::storeTickers($user, $request, $record->id);
        }

        $res = app(UserWatchList::class)->userWatchListRecords($user->id, true);
        $size = sizeof($res);
        return $this->_responseService
            ->withStatus($this->_status)
            ->multiple($size, $size, $res);
    }

    /**
     * @return \Illuminate\Http\JsonResponse
     * @throws \InvalidArgumentException|\Exception
     */
    public function updateWatchList($id)
    {
        $request = request()->all();
        $user = Auth::user();

        if (array_key_exists('tickers', $request)) {
            if (empty($request['tickers'])) {
                throw new \InvalidArgumentException('Watchlist should have at least one ticker to be valid');
            }
            $tickers = app(UserWatchList::class)->userWatchListTickers($user->id, $id, true);
            // Tickers to delete which are not part of the new payload
            $deleteTickers = array_filter($tickers, function ($ticker) use ($request) {
                return !in_array($ticker['ticker_id'], $request['tickers']);
            });
            $existingTickerIds = array_map(function ($ticker) {
                return $ticker['ticker_id'];
            }, $tickers);
            // Tickers to be added as they are not assigned to this WL record
            $insertTickers = array_filter($request['tickers'], function ($tickerId) use ($existingTickerIds) {
                return !in_array($tickerId, $existingTickerIds);
            });

            // Delete removed tickers
            UserTicker::whereIn('id', array_map(function ($ticker) {
                return $ticker['id'];
            }, $deleteTickers))->delete();
            // Add the new added tickers
            WatchListService::storeTickers($user, ['tickers' => $insertTickers], $id);
        }

        if (array_key_exists('name', $request)) {
            if (!request()->filled('name')) {
                throw new \InvalidArgumentException('Watchlist name should not be empty string of falsy value');
            }
            UserWatchList::find($id)->update(['name' => $request['name']]);
        }

        $res = app(UserWatchList::class)->userWatchListRecords($user->id, true);
        $size = sizeof($res);
        return $this->_responseService
            ->withStatus($this->_status)
            ->multiple($size, $size, $res);
    }

    // Method GET
    // Get all user email alerts
    public function getEmailAlerts()
    {
        return $this->_responseService->single(EmailAlerts::getEmailAlerts()->toArray());
    }


    // Method GET
    // Get current email alert
    /**
     * @param $id
     */
    public function getEmailAlert($id)
    {
        return $this->_responseService->single(EmailAlerts::getEmailAlert($id)->toArray());
    }


    // Method POST
    // Create new user email alert
    /**
     * @return \Illuminate\Http\JsonResponse
     * @throws \InvalidArgumentException|\Exception
     */

    public function addEmailAlert()
    {
        $request = request()->all(['module_id', 'frequency', 'enabled', 'time']);

        if (empty($request['module_id'])) {
            throw new \InvalidArgumentException('You must send the module_id in your request.');
        }

        if (empty($request['frequency'])) {
            throw new \InvalidArgumentException('You must send the frequency in your request.');
        }

        if (!array_key_exists('enabled', $request)) {
            throw new \InvalidArgumentException('You must send the enabled in your request.');
        }

        if ($request['frequency'] === 'daily' && empty($request['time'])) {
            throw new \InvalidArgumentException('For daily alerts you must select a valid time option when to receive it.');
        }

        $request['time'] = $request['frequency'] === 'daily' ? $request['time'] : null;

        return $this->_responseService
            ->withStatus($this->_status)
            ->single(EmailAlerts::createEmailAlert($request));
    }


    // Method PUT
    // Update current email alert
    public function updateEmailAlert()
    {
        $requestPayload = request()->all(['module_id', 'frequency', 'enabled', 'time']);

        if (!request()->filled('id')) {
            throw new \InvalidArgumentException('You must send the id in your request.');
        }

        if (empty(array_filter(array_values($requestPayload)))) {
            throw new \InvalidArgumentException(
                'You must send at least one of the possible fields: moduleId, frequency, enabled or time.'
            );
        }

        return $this->_responseService
            ->withStatus($this->_status)
            ->single(EmailAlerts::updateEmailAlert(request()->get('id'), $requestPayload));
    }


    // Method DELETE
    // Delete current email alert
    /**
     * @param $id
     */

    public function deleteEmailAlert($id)
    {
        return $this->_responseService
            ->withStatus($this->_status)
            ->single(EmailAlerts::deleteEmailAlert($id));
    }

    /**
     * Remove all dashboards assigned to an user and assign back preset dashboards
     * @param $id
     * @throws \Exception
     */
    public function resetUserDashboards($id)
    {
        RoleService::checkPermissions('edit-user');
        if(!isset($id)) {
            throw new \InvalidArgumentException('You must send the id in your request.');
        }
        $user = User::find($id);
        if (!$user) {
            throw new \Exception(trans('exception.recordNotFound', ['item' => 'User', 'id' => $id]));
        }
        $subscription = $user->getSubscription();
        if (!$subscription) {
            throw new \InvalidArgumentException("User doesn't have a valid subscription");
        }
        // Remove all existing dashboards assigned to user
        DB::table('user_dashboard')->where('user_id', $id)->delete();
        // Get all preset dashboards related with user subscription and assign
        UserService::updateActiveDashboardsForUser($user, $subscription->id);
        return $this->_responseService
            ->withStatus($this->_status)
            ->single(null, '', 'Dashboard updated successfully');
    }

    /**
     *
     * Collect bulk data to insert
     *
     * @return void
     * @throws \Exception
     */
    private function __getData()
    {
        $users = request()->get('users');

        foreach ($users as &$user) {
            UserService::validate($user);
            $user = UserService::resolveData($user);
        }

        $this->_data = $users;
    }
}
